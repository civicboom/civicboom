#!/usr/bin/python

from glob import glob
import re

class Param(object):
    def __init__(self, text):
        lines = text.split("\n")
        if " " in lines[0]:
            (self.name, self.desc) = lines[0].split(" ", 1)
        else:
            self.name = lines[0]
            self.desc = ""
        self.values = filter(lambda x: len(x) > 0, [l.strip() for l in lines[1:]])

    def __str__(self):
        r = ""
        r = r + self.name+" - "+self.desc+"\n"
        if self.values:
            r = r + "<ul>\n"+"\n".join(["<li>"+v for v in self.values])+"\n</ul>"
        return r

class Return(object):
    def __init__(self, text):
        lines = text.split("\n")
        (self.code, self.desc) = lines[0].split(" ", 1)
        datalines = filter(lambda x: " " in x, [l.strip() for l in lines[1:]])
        self.datas = [dl.split(" ", 1) for dl in datalines]

    def __str__(self):
        r = ""
        r = r + self.code + " - " + self.desc + "\n"
        if self.datas:
            r = r + (
                "<ul>\n"+
                    "\n".join([("<li>%s - %s" % tuple(d)) for d in self.datas])+
                "\n</ul>"
            )
        return r


class Doc(object):
    def find(self, tag):
        m = re.search("@"+tag+" ([^@]*)", self.text, re.DOTALL)
        if m:
            return m.group(1).strip()
        else:
            return None

    def findall(self, tag):
        return re.findall("@"+tag+" ([^@]*)", self.text, re.DOTALL)

    def __cmp__(self, b):
        cmp_sect = cmp(self.section, b.section)
        if cmp_sect != 0:
            return cmp_sect
        elif hasattr(self, 'title'):
            return -1
        else:
            return 1


class FuncDoc(Doc):
    def __init__(self, text):
        lines = filter(lambda x: " " in x, [l.strip() for l in text.split("\n")])
        self.text = text
        (self.method, self.desc) = lines[0].split(":", 2)
        (self.section, self.api_version) = self.find("api").split(" ", 1)
        self.params = [Param(p) for p in self.findall("param")]
        self.returns = [Return(r) for r in self.findall("return")]
        self.comments = [cl.split(" ", 1) for cl in self.findall("comment")]
        self.full = ""
        for line in lines[1:]:
            if line[0] == "@":
                break
            self.full = self.full + "\n" + line

    def __str__(self):
        params = "\n".join(["<li>"+str(p) for p in self.params])
        returns = "\n".join(["<li>"+str(r) for r in self.returns])
        dt = ""
        if self.comments:
            dt = (
                "\n".join([("<p><em>%s</em> - %s" % tuple(d)) for d in self.comments])+"\n"
            )
        return (
            "<section>\n"+
            "<h3 id='"+self.method+"'><span>"+self.api_version+"</span>"+self.method+" - "+self.desc+"</h3>\n"+
            "<div>"+
            "<p>"+self.full+"</p>" +
            ("<h4>Paramaters</h4>\n<ul>"+params+"</ul>" if params else "")+
            ("<h4>Return Data</h4>\n<ul>"+returns+"</ul>" if returns else "")+
            dt+
            "</div>"+
            "</section>\n\n"
        )


class VerbDoc(Doc):
    def __init__(self, text):
        self.text = text
        self.title = self.find("title")
        self.section = self.find("doc")
        self.desc = self.find("desc")

    def __str__(self):
        return "<h2 id='"+self.section+"'>"+self.title+"</h2>\n<div>"+self.desc+"</div>"


#
# Read the @doc and @api sections out of the files, store them
# in the right section
#

sections = {}
for controller in glob("../src/civicboom/controllers/*.py"):
    print "Scanning "+controller

    data = file(controller).read()
    for doc in data.split('"""'):
        if "@doc" in doc:
            d = VerbDoc(doc)
            if d.section not in sections:
                sections[d.section] = {'head': [], 'items': []}
            sections[d.section]['head'].append(d)
        if "@api" in doc:
            d = FuncDoc(doc)
            if d.section not in sections:
                sections[d.section] = {'head': [], 'items': []}
            sections[d.section]['items'].append(d)


fp = file("doc.html", "w")
fp.write("""<!DOCTYPE html>
<html>
    <head>
        <title>Civicboom API docs</title>
        <style>
H1 { /* document title */
    text-align: center;
    margin: 0px;
    padding: 16px;
}
ARTICLE {
    border: 1px solid grey;
    margin: 32px;
}
H2 { /* module title */
    margin: 0px;
    padding: 4px;
    border-bottom: 1px solid grey;
    background: #AAF;
}
SECTION {
    border: 1px solid grey;
    margin: 32px;
}
SECTION > DIV, ARTICLE > DIV {
    padding: 16px;
}
H3 { /* function title */
    margin: 0px;
    padding: 4px;
    border-bottom: 1px solid grey;
    background: #AAF;
}
H3 SPAN {
    float: right;
}
H4 { /* function part */
    margin: 0px;
}
H4:first-child {
}
        </style>
    </head>
    <body>
        <h1>Civicboom API docs</h1>
""")

fp.write("<ul>")
for section in sections.values():
    for doc in section['head']:
        fp.write("<li><a href='#%s'>%s</a>\n" % (doc.section, doc.title))
fp.write("</ul>")

fp.write("""
<article>
<h2>Things common to all requests:</h2>

<section>
<h3>Transport</h3>
<ul>
<li>All content-modifying actions (POST, PUT, DELETE) require an auth_token argument;
    since this is universal, it isn't mentioned in the docs for each action separately
<li>PUT and DELETE can be emulated with POST, having the form variable "_method" set
    to PUT or DELETE respectively
<li>HTTP status codes are used:
    <ul>
      <li>200 - generic success
      <li>201 - content created
      <li>400 - generic user error (commonly missing required data when submitting a form)
      <li>403 - permission denied
      <li>404 - content not found
      <li>500 - generic server error
      <li>501 - not implemented
      <li>502 - back-end server is down for maintenance
    </ul>
</ul>
</section>

<section>
<h3>Packet</h3>
<pre>
{
    "status": "ok" / "error",                              (required)
    "message": "string to show in app status bar / popup", (string or None, should be there if status = error)
    "data": {                                              (required; blank dictionary if there is no data)
        "foo": "bar", # function-specific data
        "baz": "qux"
    }
}
</pre>
</section>

<section>
<h3>Notes about this document</h3>
<ul>
<li>"WIP" = "Work in Progress; first attempt to get something that works at all"
<li>"Draft" = "It seems to work, waiting for the whole team to say Yay"
<li>"Untested" = "The team agree that it is good, but automated tests are incomplete"
<li>Just a number = "Ready to be used"
</ul>
</section>
</article>
""")

for section in sections.values():
    fp.write("<article>")
    for doc in section['head']:
        fp.write(str(doc))

    fp.write("<ul>")
    for doc in section['items']:
        fp.write("<li><a href='#%s'>%s</a>\n" % (doc.method, doc.method+" - "+doc.desc))
    fp.write("</ul>")

    for doc in section['items']:
        fp.write(str(doc))
    fp.write("</article>")

fp.write("""
    </body>
</html>
""")
fp.close()
