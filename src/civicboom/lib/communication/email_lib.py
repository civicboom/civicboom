from webhelpers.html.tools import auto_link
from webhelpers.html       import literal

from cbutils.text                          import convert_html_to_plain_text
from civicboom.lib.communication.email_log import email_log

import re

import logging
log = logging.getLogger(__name__)


config = {}


def configure(c):
    global config
    config = c


#-------------------------------------------------------------------------------
# Render Email
#-------------------------------------------------------------------------------

def render_email(subject='', content_text=None, content_html=None, html_template='/email/base_email_content.mako', **kwargs):

    # TODO!!! AllanC - This needs to be made thead safe and not use pylons libs    
    
    # Check paramiters for validity and throw exception if needed
    if content_text==None and content_html==None:
        raise EmailContentError('email content for plain text or HTML not specifyed')
    
    # Convert plain text into html by:
    #   -autolinking any links
    #   -putting inside html header
    if content_text!=None and content_html==None:
        content_html      = auto_link(content_text).replace('\n',literal('<br/>\n')) # .decode('UTF-8')
    # Convert html emails into a plain text equivlent
    elif content_html!=None and content_text==None:
        content_text      = convert_html_to_plain_text(content_html)
    
    # If not already wrapped in HTML header
    # If content HTML is not a complete document with a head and body - put it in the standard email template
    if not re.search(r'<body.*</body>',content_html, re.DOTALL + re.IGNORECASE):
        from pylons.templating  import render_mako
        content_html = render_mako(html_template, extra_vars={"kwargs": kwargs, "content_html": content_html} )
    
    # Subject - append site name to subject
    #from pylons.i18n.translation import _
    #if not subject:
    #    subject = _("_site_name")
    #else:
    #    subject = _("_site_name")+': '+subject
    
    return dict(
        subject=subject,
        content_text=content_text,
        content_html=content_html,
    )
    

#-------------------------------------------------------------------------------
# Send Email
#-------------------------------------------------------------------------------

def send_email(email_to, **kwargs):
    """
    Prepares and Send's an automated email generated by the system
    Prepares and converts between plain text and HTML content
    If email is disabled in the config it is sent to the logger
    subject='', content_text=None, content_html=None,
    """
    
    # email_to - User object passed, get email address
    # email_to - Group object passed - get list of all member emails
    #  else the email_to is assumed to be a CSV list of email address's
    #  or a python list of email address's
    if hasattr(email_to, 'email_normalized'):
        email_to = email_to.email_normalized
    if hasattr(email_to, 'all_sub_members'):
        email_to = [member.email_normalized for member in email_to.all_sub_members() if hasattr(member, 'email_normalized')] # ",".join() # no need to join as the SMTP is expecting a list
    
    # If we are not provided with both HTML and PLAIN text content they need to be generated by the render method - (the email could of been pre_rendered)
    if 'content_text' not in kwargs or 'content_html' not in kwargs:
        kwargs.update(render_email(**kwargs))
    
    if config['online'] and config['feature.aggregate.email']:
        send_email_smtp(email_to, **kwargs)
    elif config['development_mode']:
        email_log(email_to, **kwargs) # Log Debug data if send disabled
    else:
        log.warn('Email send state error - email not sent')


#-------------------------------------------------------------------------------
# Send Email - SMTP
#-------------------------------------------------------------------------------
def send_email_smtp(email_to, subject, content_text, content_html, **kwargs):
    """
    email_to can be:
      - a comma separated list (email_to)
      - a list of email strings
      
    with a subject and message body
    and sends it out to all the recipients
    No modification is made to any content
    """
    from email.mime.multipart import MIMEMultipart
    from email.mime.text      import MIMEText
    from email.mime.image     import MIMEImage
    import smtplib

    sender = kwargs.get('sender')
    if not sender:
        sender = config['email.autogen_from']
    else:
        sender = sender.strip()
    
    # Create the root message and fill in the from, to, and subject headers
    msgRoot = MIMEMultipart('related')
    msgRoot['Subject']  = subject
    msgRoot['From']     = sender
    msgRoot['Sender']   = sender
    #msgRoot['To']       = email_to
    if 'reply_to' in kwargs:
        msgRoot['Reply-To'] = kwargs.get('reply_to')
    msgRoot.preamble    = 'This is a multi-part message in MIME format.'

    # Encapsulate the plain and HTML versions of the message body in an
    # 'alternative' part, so message agents can decide which they want to display.
    msgAlternative = MIMEMultipart('alternative')
    msgRoot.attach(msgAlternative)
    
    #content_text - encoded correctly
    try:
        content_text = content_text.encode('UTF-8')
    except UnicodeError:
        pass
    msgText = MIMEText(content_text, 'plain', 'UTF-8')
    msgAlternative.attach(msgText)
    
    #content_html - encoded correctly
    try:
        content_html = content_html.encode('UTF-8')
    except UnicodeError:
        pass
    msgText = MIMEText(content_html, 'html', 'UTF-8')
    msgAlternative.attach(msgText)
    
    # Convert comma separated emails to list (if needed)
    if isinstance(email_to, basestring):
        email_to = [email.strip() for email in email_to.split(',')]
    
    # Send the email
    try:
        smtp = smtplib.SMTP()
        smtp.connect(config['email.smtp_server'], config['email.smtp_port']) #Use the smtp server from the configuration file
        smtp.ehlo()
        #sending locally so we don't need the below
        smtp.starttls()
        #need to rerun ehlo, as the smtplib on the server doesnt' do it again automatically
        smtp.ehlo()
        smtp.login(config['email.smtp_username'], config['email.smtp_password'])
        # Assuming the list is comma separated, send the message to each recipient.
        
        for recipient in email_to:
            smtp.sendmail(sender, recipient, msgRoot.as_string())
        smtp.quit()

    except smtplib.SMTPException as e:
        log.error('Unable to send email: %s' % e)
    except smtplib.socket.error as e:
        log.error('Mail server not available/misconfigured: %s' % e)
